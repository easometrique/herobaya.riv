<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Baya — Interactive Rive Demo</title>
  <style>
    :root { --bg:#f5f5f5; --card:#fff; --shadow:0 18px 60px rgba(0,0,0,.10); --ink:#171717; }
    html,body{height:100%;margin:0;background:var(--bg);font-family:system-ui,Inter,Arial,sans-serif;color:var(--ink)}
    .wrap{max-width:1200px;margin:0 auto;padding:24px}
    .card{background:var(--card);border-radius:14px;box-shadow:var(--shadow);padding:16px}
    canvas{width:100%;height:auto;display:block;background:#fff;border-radius:12px}
    .row{display:flex;gap:16px;flex-wrap:wrap;align-items:flex-start;margin-top:12px}
    .panel{background:#fff;border:1px solid #eee;border-radius:10px;padding:12px;flex:1;min-width:260px}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
    .muted{color:#777}
    button{padding:8px 12px;border-radius:8px;border:0;background:#171717;color:#fff;cursor:pointer}
    .err{color:#a40000}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <canvas id="riveCanvas"></canvas>

      <div class="row">
        <div class="panel">
          <div><strong>Controls</strong></div>
          <div style="display:flex;gap:8px;margin-top:8px;">
            <button id="play">Play</button>
            <button id="pause">Pause</button>
          </div>
          <div class="mono muted" id="status" style="margin-top:8px">Loading…</div>
          <div class="mono muted" style="margin-top:8px">
            Pointer: <span id="pt">x=0.50, y=0.50</span> · CTA: <span id="cta">out</span>
          </div>
        </div>

        <div class="panel">
          <div><strong>Debug</strong></div>
          <div class="mono muted" style="margin-top:6px">
            State machine: <span id="smName">—</span>
          </div>
          <div class="mono muted" style="margin-top:6px">
            Inputs: <div id="inputsList" class="mono"></div>
          </div>
          <div id="errorBox" class="mono err" style="display:none;margin-top:8px"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/@rive-app/canvas@2.11.0"></script>
  <script>
    // ======= EDIT IF NEEDED =======
    const RIV_FILE      = 'baya_hero_project.riv'; // your .riv
    const STATE_MACHINE = 'HeroMachine';

    // Input names (must match exactly, case-sensitive)
    const INPUTS = {
      birdTrack : 'Bird_Tracking',   // Number 0..1 (cursor X)
      btnHover  : 'Button_Hover',    // Bool
      clickCTA  : 'Click_CTA'        // Trigger or Bool
    };

    // Canvas → artboard aspect ratio
    const SCENE_W = 1200, SCENE_H = 800;

    // CTA hit-area (x,y,w,h in 0..1). Tweak to your layout.
    const CTA_RECT = { x: 0.62, y: 0.70, w: 0.26, h: 0.12 };
    // ==============================

    const canvas = document.getElementById('riveCanvas');
    const statusEl = document.getElementById('status');
    const errorEl  = document.getElementById('errorBox');
    const inputsEl = document.getElementById('inputsList');
    const smEl     = document.getElementById('smName');
    const ptEl     = document.getElementById('pt');
    const ctaEl    = document.getElementById('cta');

    let app, inputs = {}, rafPending = false, lastPoint = {x:0.5, y:0.5};

    function sizeCanvas() {
      const dpr  = window.devicePixelRatio || 1;
      const cssW = canvas.clientWidth || SCENE_W;
      const cssH = cssW * (SCENE_H/SCENE_W);
      canvas.style.height = cssH + 'px';
      canvas.width  = Math.round(cssW * dpr);
      canvas.height = Math.round(cssH * dpr);
      if (app) app.resizeDrawingSurfaceToCanvas();
    }

    const inRect = (p, r) => p.x>=r.x && p.x<=r.x+r.w && p.y>=r.y && p.y<=r.y+r.h;

    function updateInputs(p) {
      if (inputs.birdTrack) inputs.birdTrack.value = p.x;

      const overCTA = inRect(p, CTA_RECT);
      if (inputs.btnHover) inputs.btnHover.value = overCTA;
      ctaEl.textContent = overCTA ? 'over' : 'out';
    }

    function scheduleUpdate(p) {
      lastPoint = p;
      ptEl.textContent = `x=${p.x.toFixed(2)}, y=${p.y.toFixed(2)}`;
      if (rafPending) return;
      rafPending = true;
      requestAnimationFrame(() => {
        rafPending = false;
        updateInputs(lastPoint);
      });
    }

    function normFromEvent(e) {
      const rect = canvas.getBoundingClientRect();
      const cx = 'touches' in e ? e.touches[0].clientX : e.clientX;
      const cy = 'touches' in e ? e.touches[0].clientY : e.clientY;
      let nx = (cx - rect.left) / rect.width;
      let ny = (cy - rect.top)  / rect.height;
      return { x: Math.max(0, Math.min(1, nx)), y: Math.max(0, Math.min(1, ny)) };
    }

    function bindPointer() {
      const onMove = e => { scheduleUpdate(normFromEvent(e)); };
      canvas.addEventListener('mousemove', onMove);
      canvas.addEventListener('touchmove', e => { onMove(e); e.preventDefault(); }, { passive:false });

      const tryClick = () => {
        if (!inputs.clickCTA) return;
        const overCTA = inRect(lastPoint, CTA_RECT);
        if (!overCTA) return;
        if (inputs.clickCTA.fire) inputs.clickCTA.fire();
        else if ('value' in inputs.clickCTA) {
          inputs.clickCTA.value = true;
          setTimeout(()=> inputs.clickCTA.value = false, 120);
        }
      };
      canvas.addEventListener('pointerdown', tryClick);
      canvas.addEventListener('click', tryClick);
    }

    function listInputs(smName) {
      smEl.textContent = smName;
      const list = app.stateMachineInputs(smName) || [];
      inputsEl.innerHTML = list.length
        ? list.map(i => {
            const t = i.type === rive.SMIInputType.Number ? 'Number' :
                      i.type === rive.SMIInputType.Bool   ? 'Bool'   :
                      i.type === rive.SMIInputType.Trigger? 'Trigger': 'Unknown';
            return `<div class="mono">${i.name} <span class="muted">(${t})</span></div>`;
          }).join('')
        : '<span class="muted">No inputs found.</span>';

      inputs.birdTrack = list.find(i => i.name===INPUTS.birdTrack && i.type===rive.SMIInputType.Number);
      inputs.btnHover  = list.find(i => i.name===INPUTS.btnHover  && i.type===rive.SMIInputType.Bool);
      inputs.clickCTA  = list.find(i => i.name===INPUTS.clickCTA); // Trigger or Bool
    }

    function init() {
      sizeCanvas();
      window.addEventListener('resize', sizeCanvas);

      try {
        app = new rive.Rive({
          src: RIV_FILE,
          canvas,
          autoplay: true,
          stateMachines: STATE_MACHINE,
          fit: rive.Fit.CONTAIN,
          alignment: rive.Alignment.center,
          onLoad: () => {
            sizeCanvas();
            statusEl.textContent = 'Ready.';
            listInputs(STATE_MACHINE);
            bindPointer();
          }
        });
      } catch (e) {
        errorEl.style.display = 'block';
        errorEl.textContent = 'Rive init error: ' + e.message;
        statusEl.textContent = 'Error.';
      }
    }

    document.getElementById('play').onclick  = () => app && app.play();
    document.getElementById('pause').onclick = () => app && app.pause();

    init();
  </script>
</body>
</html>
